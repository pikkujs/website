---
sidebar_position: 2
title: Services
description: How services work
---

The first step in Vramework is setting up the services.

Services in Vramework are a fundamental way for functions to access any form of state outside of them.

There is nothing particularly special about most services, other than optionally requiring an initialization and destruction endpoint.

For example, here is a service endpoint for storing and retrieving books. Note that it does not rely on any Vramework-specific concepts or libraries.

It is also important to note the use of the `NotFoundError`. This is identified by vramework when thrown and is mapped to the correct message. You can look into this further in the advanced section.

```typescript
import { Book, Books, CreateBook } from "./books.types";
import { NotFoundError } from "@vramework/core/errors"

/**
 * Service for managing books with basic CRUD operations.
 */
export class BookService {
    private books: Book[] = [];
    private nextId: number = 1;

    /**
     * Creates a new book and adds it to the collection.
     * @returns The newly created book.
     */
    createBook(book: CreateBook): Book {
        const newBook: Book = { id: this.nextId++, ...book };
        this.books.push(newBook);
        return newBook;
    }

    /**
     * Retrieves a book by its unique ID.
     * @returns The updated book object if the book exists, or throws a `NotFoundError` otherwise.
     */
    getBook(id: number): Book | undefined {
      const book = this.books.find(book => book.id === id);
      if (!book) {
        throw new NotFoundError(`Book with ID ${id} not found`)
      }
    }

    /**
     * Retrieves the list of all books in the collection.
     * @returns An array of all books.
     */
    getBooks(): Books {
      return this.books;
    }

    /**
     * Updates the properties of a book with the given ID.
     * @returns The updated book object if the book exists, or throws a `NotFoundError` otherwise.
     */
    updateBook(id: number, updatedInfo: Partial<Omit<Book, 'id'>>): Book {
      const book = this.getBook(id);
      if (book) {
          Object.assign(book, updatedInfo);
          return book
      }
      throw new NotFoundError(`Book with ID ${id} not found`)
    }

    /**
     * Deletes a book with the specified ID from the collection.
     * @returns `true` if the book was successfully deleted, or `false` if no book with the given ID was found.
     */
    deleteBook(id: number): boolean {
      const index = this.books.findIndex(book => book.id === id);
      if (index !== -1) {
          this.books.splice(index, 1);
          return true;
      }
      return false
    }
}
```

## Services Theory

Vramework is built around a combination of dependency lookup and dependency injection.

There are two types of services in Vramework:

### Singleton Service

A singleton service is created once for the entire server. Its lifetime begins when the server starts and ends when the server shuts down.

Example core services include:

- **Session Management**: A service used to validate user sessions
- **Database**: To create an ORM/database pool connection
- **Email Provider**: To send email templates

### Session Service / HTTP Session Service

A session service is created on demand for each API call. Its lifetime is tied to the duration of the call itself. The service is aware of the user session, and is destroyed once the call concludes.

Session services can also access the underlying request and response objects for non-standard behavior.

Example session services include:

- **HTTPRequestService**: Provides access to request information (such as headers or binary payloads)
- **HTTPResponseService**: Provides access to the response object, to set cookies or a redirect.
- **Database Client**: A database client that performs transactions (which can enable features like auto-auditing)
- **TemporaryFileService**: Creates a temporary folder that is automatically deleted once the call is complete

A session service can optionally implement the `SessionService` interface, which includes a single function, `closeSession`, to destroy the service upon completion.

**Important**: Session services should always be lazy-loaded or created on demand. This means that while the class itself is created and provided with session context, it should not perform any operations until it is called. This approach prevents any unrequired work being done.

## Creating Services

Vramework does not incorporate extensive "magic" in service creation. Instead, it relies on straightforward functions that return an object with all services, along with a factory function for creating session services.

First, define your custom types. Since this example is really simple, we aren't actually adding anything other than a single service. Future workflows will demonstrate how to build ontop of this.

```typescript title="api.ts"
import { CoreConfig, CoreSingletonServices, CoreUserSession } from '@vramework/core/types'
import { BookService } from './book.service'

/**
 * Provide any extra config that your services will use
 */
export interface Config extends CoreConfig {

}

/**
 * All custom singleton services can be defined here
 */
export type SingletonServices = CoreSingletonServices & {
  books: BookService
}

/**
 * 
 */
export interface Services extends CoreHTTPServices {

}

/**
 * Define your user session here
 */
export interface UserSession extends CoreUserSession {

}
```

Then, create the services to populate these objects.

```js reference title="Example"
https://github.com/saucelabs/docusaurus-theme-github-codeblock/blob/main/src/theme/ReferenceCodeBlock/index.tsx#L105-L108
```

```typescript title="services.ts"
import { ConsoleLogger } from '@vramework/core/services/logger'
import { Config, SingletonServices } from './api'
import { BookService } from './book.service'

export const createSingletonServices = async (config: Config): Promise<SingletonServices> => {
  const logger = new ConsoleLogger()

  if (config.logLevel) {
    logger.setLevel(config.logLevel)
  }

  return {
    config,
    logger,
    books: new BookService()
  } 
}
```

## Dependency Lookup vs Dependency Injection

In Vramework, services are not scoped to each module. This means that if multiple email providers are used (e.g., SendGrid and SES), it is necessary to specify which provider is being used in each context.

For example:

```typescript
const sendEmail = async (services, data, session) => {
    const { email } = services
    email.sendgrid.send()
    email.ses.send()
}
```

**Opinion**: The logic between which email provider is to be used is required should happen within the service itself, reducing the cognitive load of managing different providers. The service initializer can handle the specifics of how to proceed.

Using interfaces for services allows for switching out providers within the `services.ts` file.

Here is a comparison between dependency lookup and dependency injection:

| **Aspect**               | **Dependency Lookup**                                             | **Dependency Injection**                                         |
|--------------------------|------------------------------------------------------------------|------------------------------------------------------------------|
| **Dependency Acquisition**| Object retrieves dependencies when needed.                      | Dependencies are provided to the object at creation.             |
| **Responsibility**        | The object controls how and when to access its dependencies.     | The framework or external entity manages the dependencies.       |
| **Flexibility**           | Offers flexibility by allowing the object to decide when to fetch dependencies. | Dependencies are provided upfront, reducing runtime decisions.   |
| **Coupling**              | Can lead to tighter coupling, as the object knows where to find dependencies. | Promotes loose coupling by not requiring the object to know about the source of its dependencies. |
| **Testability**           | May require more effort to mock dependencies for testing.        | Simplifies testing, as dependencies are easily injected.         |
| **Use Case**              | Suitable when runtime flexibility in dependency resolution is needed. | Useful for systems that prioritize decoupling and testability.   |

## Advanced

One significant benefit of using injected or looked-up services is that it is not always necessary to interact with cloud providers or online/third-party services. Often, local alternatives suffice. This philosophy is central to Vramework.

An example shows how to switch between local and cloud services (not for production!) by setting `NODE_ENV` to production.

The implementation approach is flexible. The `isProduction` check can be placed either inside the `createServices` function or within the service itself.

```typescript title="services.ts"
const isProduction = process.env.NODE_ENV === 'production'
let content: S3Content | LocalContent
if (isProduction || process.env.PRODUCTION_SERVICES) {
  const keypairId = await secrets.getSecret(config.secrets.cloudfrontContentId)
  const privateKeyString = await secrets.getSecret(config.secrets.cloudfrontContentPrivateKey)
  content = new S3Content(config.content, logger, { keypairId, privateKeyString })
} else {
  content = new LocalContent(config, logger as any)
}
```

Alternatively, for unit tests, a `createServicesStubs` file can be used to mock all interfaces using tools like SinonJS or Jest. This approach also accommodates those who prefer to develop their own testing frameworks.
