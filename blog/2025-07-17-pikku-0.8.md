---
title: Pikku 0.8, the biggest release yet!
description: Adding Queues, MCP Servers, RPCs and Optimized bundles!
---

I'm super excited to announce Pikku 0.8, which now includes all the features I have to expect in any Typed backend framework, plus an MCP Server ontop.

There are alot of new features in here, so we'll start first with RPCs and move our way up!

Before I begin, let's just do a quick recap of what Pikku does.

The heart of pikku is a function:

```typescript
const updateTodo = pikkuFunc<Todo, { updated: boolean }>({
  func: async ({ logger, todoService }, { todoId, ...data }, session) => {
    await todoService.update(todoId, data) 
    return { updated: true }
  },
  permissions: {
    canEditTodo: ({ database }, data, session) => {
        const { ownerId } = await todoService.get(data.todoId)
        return ownerId === session.userId
    } 
  }
})
```

Which can then be wired up to HTTP using:

```typescript
addHTTPRoute({
    method: 'patch',
    func: updateTodo
})
```

You can do the same for cron jobs, websocket messages, and now in 0.8 with RPC calls / Qeueues and MCP servers.

Different transport types expect different Inputs/Outputs, but it's always the same signature, with a few utility functions to make life easier.

Let's look at new features!

# RPC (remote procedure calls)

We can now call RPCs from other functions! If we look at the example we had before:

```typescript
const sendTodoChangedEmail = pikkuFunc<{ type: 'todo-changed', todoId: string }, void>({
  func: async ({ email }, { type, todoId }, session) => {
    await email.send(...)
  },
  expose: false // This means it can only be invoked locally
})

const updateTodo = pikkuFunc<Todo, { updated: boolean }>({
  func: async ({ logger, todoService, rpc }, { todoId, ...data }, session) => {
    await todoService.update(todoId, data) 
    // We can now do this!
    await rpc.invoke('send-Email', { type: 'todo-changed', todoId })
    return { updated: true }
  },
  expose: true // This means it is exposed similar to HTTP functions
})
```

This is important for a couple of reasons:

1) It allows us to know which services are being used, which is extremely useful for tree shaking.
2) It means we could also invoke remote RPC's. You don't need to know if the function is running in your instance or not.
3) Based on 2, it also allows us to expose the RPC's to a frontend client as well, with full typing.

```typescript
const rpc = new PikkuRPC()
const result = await rpc.invoke('update-todo', { type, todoId })
```

And as always, this will check if you required a user session, validate against permissions on the function itself and validate your payload against the json-schema generated from your typescript interface before invoking it.

Think tRPC, but with support for services, permissions, auth and allowing your methods to be also be exposed via HTTP (with openAPI documentation) or WebSockets.

# Queued Tasks

Async Tasks are a corner stone of most modern applications. NestJS uses bullMQ via redis, pg-boss and other libraries use postgres, and dedicated queue services exists, like Nat and RabbitMQ. Then we have AWS SQS that can run your jobs via lambdas and completely change how scaling works.

They all have something in common, the ability to add tasks to a queue and have a work consume those tasks async and return the result once completed.

Trying to reach feature parity across all these queues is a huge undertaking, which we didn't want to get into. So we instead went for the pikku approach:

How can I add a task to a queue, and have that task be picked up and processed via a function.

To do so, you might have guessed it, we declared a function and wire it up:

```typescript
export const queueWorker = pikkuSessionlessFunc<
  { message: string; fail: boolean },
  { result: string }
>(async ({}, data) => {
  await new Promise((resolve) => setTimeout(resolve, 1000))
  if (data.fail) {
    throw new Error('Job failed because it was instructed to')
  }
  return { result: `echo: ${data.message}` }
})

addQueueWorker({
  queueName: 'hello-world-queue',
  func: queueWorker,
})
```

In the case of bullMQ, we create an instance:

```typescript
const bullQueueWorkers = new BullQueueWorkers(
  {},
  singletonServices,
  createSessionServices
)
await bullQueueWorkers.registerQueues()
```

And that's it. We now registered our functions against the queues. 

On the client side, we also have really thin wrappers around the client libraries so they provide fully typed jobs and confirm to a single API, allowing us to switch out easily.

```typescript
const bullQueueService = new BullQueueService()
const queueService = new PikkuQueue(bullQueueService)

const queueJob = await queueService.add('hello-world-queue', {
  message: 'Hello from Bull!',
  fail: false,
})
const job = await queueService.getJob('hello-world-queue', queueJob)
console.log(job.waitForCompletion?.())
```

It's worth noting you can use the default clients directly, the PikkuClients are just a small layer of abstraction to allow you to switch between queue systems in minutes, which is useful if you have both an offline/enterprise and cloud solution via the same codebase.

# MCP Server

This part is more experimental, it does work but I haven't yet comeup with actual cases and given how quickly things change it's hard to tell how it will evolve.

The idea is that we can add Prompts, Tools and Resources via functions, same as everything else.

The mcp.json (including the schemas and everything else) is automatically generated. This means just by writing your functions and wiring them up you can get an MCP agent running!

```typescript
/**
 * A simple hello world MCP tool that greets the user
 */
export const sayHello = pikkuMCPToolFunc<{ name?: string }>(
  async (services, { name = 'World' }) => {
    services.logger.info(`Saying hello to: ${name}`)

    return [
      {
        type: 'text',
        text: `Hello, ${name}! This is a Pikku MCP tool.`,
      },
    ]
  }
)

/**
 * A mock user information resource that returns user data
 */
export const getUserInfo = pikkuMCPResourceFunc<{ userId: string }>(
  async ({ users, logger }, { userId }) => {
    logger.info(`Getting user info for: ${userId}`)

    const users = users[userId]
    if (!user) {
      throw new NotFoundError(`User not found: ${userId}`)
    }

    return [
      {
        uri: `getUserInfo/${userId}`,
        text: JSON.stringify(user),
      },
    ]
  }
)

/**
 * A progress enhancement example prompt that shows how to create dynamic prompts with arguments
 */
export const dynamicPromptGenerator = pikkuMCPPromptFunc<{
  topic: string
  complexity: 'beginner' | 'intermediate' | 'advanced'
  includeExamples?: string
}>(async (services, { topic, complexity, includeExamples = false }) => {
  services.logger.info(
    `Generating progressive enhancement content for: ${topic} (${complexity})`
  )

  let content = `# Progressive Enhancement for ${topic}\n\n`

  switch (complexity) {
    case 'beginner':
      content += `This is a beginner-friendly introduction to ${topic}.\n\n`
      content += `Start with the basics and build up your understanding gradually.\n`
      break
    case 'intermediate':
      content += `This is an intermediate guide to ${topic}.\n\n`
      content += `Assumes some familiarity with related concepts.\n`
      break
    case 'advanced':
      content += `This is an advanced discussion of ${topic}.\n\n`
      content += `Deep dive into complex scenarios and edge cases.\n`
      break
  }

  if (includeExamples) {
    content += `\n## Examples\n\n`
    content += `Here are some practical examples for ${topic}:\n`
    content += `- Example 1: Basic implementation\n`
    content += `- Example 2: Advanced use case\n`
    content += `- Example 3: Common pitfalls to avoid\n`
  }

  return [
    {
      role: 'user' as const,
      content: {
        type: 'text' as const,
        text: content,
      },
    },
  ]
})


// Register a simple greeting tool
addMCPTool({
  name: 'sayHello',
  description: 'Greet someone with a friendly hello message',
  func: sayHello,
  tags: ['greeting', 'hello', 'demo'],
})

addMCPResource({
  uri: 'getUserInfo/{userId}',
  title: 'User Information',
  description: 'Retrieve user information by user ID',
  func: getUserInfo,
  tags: ['user', 'profile', 'data'],
})


// Register a progressive enhancement example prompt
addMCPPrompt({
  name: 'dynamicPromptGenerator',
  description:
    'Generate educational content with progressive complexity and optional examples',
  func: dynamicPromptGenerator,
  tags: ['education', 'content', 'progressive', 'examples'],
})
```

And to run it:

```typescript
const server = new PikkuMCPServer(
  {
    name: 'pikku-mcp-server',
    version: '1.0.0',
    // This is generated via pikku
    mcpJsonPath: join(__dirname, '../../functions/.pikku/mcp.gen.json'),
    capabilities: {
      logging: {},
      tools: {},
      resources: {},
      prompts: {},
    },
  },
  singletonServices
)
await server.init()
const transport = new StdioServerTransport()
await server.connect(transport)
server.wrapLogger()
```

# Service Shaking

And last, but certainly not least, we can now filter our functions directly using the "pikku --tags 'tag name'" function. This will provide us with a map of all the services we need, which means we can optionally load them, allowing us to pretty much strip down our bundle size / dynamically load services only when needed.

```typescript
/**
 * This function creates the singleton services used by the application and is created once on start.
 * It's important to use the types here, as the pikku CLI uses them to improve the development experience!
 */
export const createSingletonServices: CreateSingletonServices<
  Config,
  RequiredSingletonServices
> = async (config: Config): Promise<RequiredSingletonServices> => {
  const variables = new LocalVariablesService()
  const logger = new ConsoleLogger()

  const schema = new CFWorkerSchemaService(logger)

  // Only create JWT service if it's actually needed
  let jwt: JWTService | undefined
  if (singletonServices.jwt) {
    const { JoseJWTService } = await import('@pikku/jose')
    jwt = new JoseJWTService(
      async () => [
        {
          id: 'my-key',
          value: 'the-yellow-puppet',
        },
      ],
      logger
    )
  }

  return {
    config,
    logger,
    variables,
    schema,
    jwt,
  }
}
```
