---
title: "Vramework 0.6: In depth"  
description: The longer version of the vramework 0.6 release
---

# Announcing Vramework 0.6: In depth version

Read more into what vramework is and features in this release!

<!-- truncate -->

Before diving into the new features, let’s briefly reintroduce Vramework. With these changes, we’re stepping beyond the boundaries of **Node.js HTTP servers** and into a broader ecosystem that lets you truly **write once and run anywhere**.

## Vramework (Re)(Re)Introduction

Vramework is a lightweight, TypeScript-powered framework that encourages a **function-first approach** to building backend applications. Instead of tying you to a single runtime, it uses pure TypeScript and interface-based APIs to normalize differences across various environments. A specialized build-stage compiler extracts all your type information, ensuring that your entire project remains consistent and strongly typed.

**What Vramework isn’t:** It’s not another server. Instead, it provides a minimal runtime that delegates all HTTP, WebSocket, and streaming duties to underlying servers like **[uWebSockets.js (uWS)](https://github.com/uNetworking/uWebSockets.js)**, **[Express](https://expressjs.com/)**, or **[Fastify](https://www.fastify.io/)**. You choose the environment—Node.js today, **Bun** or **Deno** tomorrow—and deploy on containers, serverless platforms, or VMs without changing your code.

At its core is the `APIFunction`. You attach these functions to HTTP endpoints, WebSockets, or scheduled tasks. Add permission guards, authentication checks, and auto-generated documentation seamlessly. The result? A more flexible, testable, and maintainable backend.

### No Server Commitments

**Pick any underlying server you want—no strings attached.** Want to switch from uWS to Express or WS for WebSockets? Vramework won’t get in your way.

:::note
Setting up features like CORS or multipart file uploads depends on the underlying runtime. Many functionless deployments prefer external services like S3 or Azure Storage for file handling, leaving your Vramework code clean and focused.
:::

### No Runtime Commitment

**Trying out new runtimes should be easy, not painful.** Move from Node.js to Bun or Deno with minimal fuss. While official support for Bun and Deno is still being refined, we’re laying the groundwork so these transitions are as smooth as possible.

:::note
Bun support is unofficially here, and Deno support is on the roadmap. We’re aiming to harmonize differences in their core APIs so you can pick the runtime that suits you best.
:::

### No Deployment Commitments

**Deploy anywhere without rewriting:** Run your code in Docker on Kubernetes or deploy just a few functions to AWS Lambda or Azure Functions. You’ll maintain a unified developer experience no matter the platform.

Develop locally on a simple server—no heavy cloud simulations needed. For complex integration tests, you can still spin up realistic environments, but your day-to-day development remains simple and fast.

### TypeScript, TypeScript, TypeScript

Vramework emerged from a desire for a fully typed codebase without tedious manual wiring. Version 0.5 introduced **@vramework/cli**, a compile-time CLI that extracts type definitions from your code. With this data, Vramework can:

- **Automatically generate OpenAPI documentation** from your function types.
- **Produce schemas for route validation** to catch errors early.
- **Create typed fetch clients** that act as ready-to-use SDKs for your frontend.

Integrate with something like `kysely-codegen` and watch your database schema changes propagate through both frontend and backend code as type errors, ensuring nothing breaks silently. It’s the closest you’ll get to “just works” for type safety.

## New Features

Now, onto the fun stuff Vramework 0.6 brings to the table!

### Scheduled Tasks

**Scheduled Tasks** extend Vramework’s flexibility beyond typical request/response lifecycles. You can now register any `APIFunctionSessionless<void, void>` along with a cron-like schedule:

```typescript
import { addScheduledTask } from '@vramework/core/scheduler'

export const myScheduledTask: APIFunctionSessionless<void, void> = async (services) => {
    // For example, sync database records daily:
    // await services.db.syncRecords();
}

addScheduledTask({
    name: 'myScheduledTask',
    schedule: '*/1 * * * *',
    func: myScheduledTask,
})
```

Run these tasks on a local server for development, in Docker for staging, or on a serverless platform’s scheduled events for production—all with the same typed, integrated code. [Read more in the Scheduled Task docs](//docs/24-scheduled-tasks/10-scheduled-task.md).

### Channels

Having started my career in realtime development and serving as a **core contributor to [deepstream.io](https://deepstream.io)**, I’ve seen firsthand the challenges of building scalable, event-driven backends. Drawing on that experience and guided by [AsyncAPI](https://www.asyncapi.com/), **Channels** in Vramework let you define typed, function-based handlers for WebSocket connections. This approach brings the reliability, flexibility, and type safety you’ve come to expect from Vramework into the realm of realtime communication.

You might use Channels to power a live chat feature, send notifications to connected clients, or broadcast stock price updates in real time. The best part? They’re just as flexible as everything else in Vramework—run them on fast servers like uWS, use standard WS libraries, or deploy them to serverless WebSocket platforms without code rewrites.

[Learn more about Channels](//docs/23-channels/00-channel-intro.md).

#### New Channel Functions

```typescript
// Called on connect. Setup code, send initial data, etc.
export const onConnect: ChannelConnection<'hello!'> = async (services, channel) => {
    services.logger.info('Connected to event channel')
    channel.send('hello!')
}

// Called on disconnect. Cleanup or logging—no more messages can be sent.
export const onDisconnect: ChannelDisconnection = async (services, channel) => {
    services.logger.info('Disconnected from event channel')
}

// Called when a message is received. Authenticate users, authorize actions.
export const authenticate: ChannelMessage<{ token: string }, { authResult: boolean }> = async (services, channel, data) => {
    const authResult = data.token === 'valid'
    if (authResult) channel.setSession({ userId: 'Bob' })
    channel.send({ authResult })
}
```

#### Subscription Service

Channels also integrate seamlessly with a subscription service, giving you a built-in pub/sub mechanism:

```typescript
export const subscribe: ChannelMessage<{ name: string }> = async (services, channel, data) => {
  await channel.subscriptions.subscribe(data.name, channel.channelId)
}

export const unsubscribe: ChannelMessage<{ name: string }> = async (services, channel, data) => {
  await channel.subscriptions.unsubscribe(data.name, channel.channelId)
}

export const emitMessage: ChannelMessage<{ name: string }, { timestamp: string } | { message: string }> = async (services, channel, data) => {
  await channel.subscriptions.broadcast(data.name, channel.channelId, { timestamp: new Date().toISOString() })
  await channel.broadcast({ message: `broadcasted from ${channel.channelId}` })
}
```

This setup covers everything from small-scale chat apps to large, distributed realtime systems. It also makes it easier to consider stateless, serverless architectures where you can scale WebSocket handling without sticky sessions. For more insights, check out [this blog on sticky sessions’ benefits and drawbacks](https://dev.to/rahulvijayvergiya/sticky-sessions-benefits-and-drawbacks-68n#:~:text=Drawbacks%20of%20Sticky%20Sessions&text=Scalability%20Issues%3A%20Sticky%20sessions%20can,the%20scalability%20of%20the%20application.).

### Compiler Improvements

In version 0.6, we’ve pushed compile-time analysis even further. You can now define input and output types directly in your functions, and Vramework’s CLI will generate types automatically.

```typescript
const updateBirthday: APIFunction<{ userId: string; birthday: number }, { success: boolean }> = async (services, data) => {
  // Implementation...
}
```

During compile time, Vramework creates:

```typescript
export type UpdateBirthdayInput = { userId: string, birthday: number }
export type UpdateBirthdayOutput = { success: boolean }
```

**No more redundant type declarations, no decorators, just pure TypeScript.**

:::note
Primitive types (boolean, string, number) as parameters or returns are not currently supported, but we’re refining this for future releases.
:::

## Features Dropped

**Why remove features?** To maintain focus, simplify the codebase, and pave the way for cleaner, more robust extensions in future versions.

### CommonJS

Juggling ESM and CJS was painful and time-consuming. We’ve embraced ESM as the future. Node.js supports it natively, and upcoming Bun/Deno integration also prefers ESM. This simplification makes Vramework leaner and more forward-looking.

### Next.js

Next.js integration became less appealing as the framework introduced complexities with headers/cookies and other server-side rendering magic. We’ve removed Next.js 14 support and Next.js pages for now. This decision lets us focus on what Vramework does best: providing a flexible, typed backend ecosystem rather than bending to a single frontend framework’s quirks.

### Embedded Functions

We’ve removed embedded functions in route definitions. While convenient in theory, they introduced complex edge cases and slowed down code generation. By dropping them, we’ve simplified the codebase, making it easier to maintain and opening the door for even more powerful features in the future.

---

**In summary,** Vramework 0.6 continues to deliver on the promise of flexibility, type safety, and runtime/deployment agnosticism. With scheduled tasks, channels, and improved compile-time insights, you can build powerful backends that adapt to your environment and scale with your ambitions—without locking yourself into a single pattern, platform, or runtime.

**Ready to get started?**  
- Check out the [documentation](https://github.com/vramework/vramework) for more details.  
- Try out a simple scheduled task or a channel-based realtime feature.  
- Contribute your feedback, ideas, or bug reports via [GitHub issues](https://github.com/vramework/vramework/issues).  
- Join the conversation and help shape the future of Vramework.

We can’t wait to see what you build with these new capabilities. **Happy hacking!**